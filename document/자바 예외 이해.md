# 예외 계층
- 스프링 예외 추상화를 이해하기 위해서는 자바 기본 예외에 대한 이해가 필요하다.


- Object
  - Throwable -> catch에서 이 예외로 잡으면, Error까지 함께 잡을 수 있기 떄문에, Exception 레벨부터 예외를 잡으면 된다.
    - Exception
      - SQLException (체크 예외)
      - IOException (체크 예외)
      - RuntimeException (언체크 예외)
        - NullPointerException
        - IllegalArgumentException
    - Error -> (체크 예외)
      - OutOfMemoryError -> 시스템 오류, 코드로 제어하려고 하지 말고 그대로 에러를 내뱉는게 자연스럽다.

# 예외 기본 규칙
- 예외가 발생하면 예외 처리를 못하면 예외를 던지고 예외 처리가 가능한 곳에서 예외를 처리한다.
- 예외를 처리하지 못하면, 호출한 곳으로 예외를 계속 던지게 된다. 
  - 즉 잡아서 처리하거나, 예외를 던지거나!
  - 상위 예외는 하위 예외를 모두 catch로 잡거나 던질 수 있다. 
- 예외를 처리하지 못 하고 예외를 던진다면, 메인 쓰레드의 경우 예외 로그 출력하면서 시스템이 종료된다.
  - 메인쓰레드 밖으로 예외가 던져지면 App이 종료가 되는데, 웹 앱은 이용자가 많고 요청이 많기 때문에, 서비스가 종료되면 안 되고, WAS가 해당 예외를 잡아 처리 한다.  

# 체크 예외 기본 이해
- 체크 예외는 예외 처리 로직이 있어야 하고, 없다면 컴파일 에러가 발생한다.
- Exception을 상속받은 예외는 체크 예외가 된다.
- 예외를 던지는 메소드를 만들었을 때, 체크 예외를 던지는 경우, 메소드에 던지는 Exception을 선언해줘야 한다. 안 하면 컴파일 에러 발생!
  - 예외를 던졌을 때, 받는 쪽에서도 마찬가지로 메소드에 Exception을 같이 선언해줘야 한다.
- 가장 좋은 에러는 컴파일 에러다. 서비스 도중에 예외가 발생하지 않도록, 컴파일 에러를 유발시키는 것이 필요하다. 
  - 하지만 모든 예외를 잡거나 처리해야 하기 때문에, 번거롭고 예외를 신경써야 한다.

# 언체크 예외 기본 이해
- 컴파일러가 예외를 체크하지 않는다.
- throw를 선언하지 않고 생략 가능하다. 
- 체크 예외는 예외 처리, 던짐을 반드시 해야하지만, 언체크 예외는 예외 처리를 하지 않아도 throw를 생략 가능하다. 
  - 작은 차이지만 많은 차이를 만들어낸다.
  - 필요한 경우 예외 처리 로직을 하면 된다. 

체크 예외와 언체크 예외의 경우 예외 처리 로직이 필수냐 아니냐에 따라 차이점이 나뉘는데, 각각의 장단점이 존재하지만,  
이를 활용하는 쪽에서는 어마어마한 차이를 낼 수 있다.

# 체크 예외 활용
- 기본 원칙 두 가지 
  1. 기본적으로 언체크(런타임) 예외를 사용하자.
  2. 체크 예외는 비즈니스 로직상 의도적으로 던지는 예외에만 사용하자.
     - 예외를 잡아서 반드시 처리해야하는 경우, 예를 들면 계좌 이체 실패, 결제시 포인트 부족 예외, 로그인 실패 예외
       - 예외를 놓치면 안된다고 판단이 될 때 컴파일러를 통해 놓친 예외를 쉽게 인지 가능하다.

- 체크 예외는 잘 안 쓴다. 반드시 필요한 예외 처리일 때 사용하자.
  - 런타임 예외를 사용하는 것이 추세~.~
  

- 체크 예외의 문제점
  - 컴파일러가 예외를 인지하게 해주고, 예외를 잡거나 처리하게 해준다.
  - 예외 공통 처리(ControllerAdvice) - SQLException, ConnectException
  - Controller - SQLException, ConnectException
    - Service - SQLException, ConnectException
      - Repository - SQLException
      - NetworkClient - ConnectException

서비스에서는 Repository, NetworkClient에서 던지는 체크 예외를 처리해야 하고, 받는 쪽에서도 마찬가지로 다 처리 로직이 들어가야 한다.  
ControllerAdvice가 예외를 공통으로 잡아서 처리를 해야하는데, 이용자에게 보여지는 예외는 시스템의 디테일한 부분을 말해줄 필요가 없다.  
잘못하면 보안의 문제가 될 수도 있다. 따라서 별도의 로그를 남기고(알람, 문자, 슬랙 등)  
위에 예제에서 체크 예외는 SQLException에 의존하게 된다. SQLException은 JDBC 기술로써, 향후 JDBC가 아닌 다른 데이터 접근 구현체를  
이용하게 될 때 코드 수정을 초래할 수도 있다.  (SQLException -> JPAException)  
구체적인 기술에 의존하게 되고, 처리하지 못하고 계속적으로 던짐으로써 발목이 잡히게 된다. -> 불필요한 의존관계가 생기게 된다.  
구체적인 예외 대신, Exception 예외로 모든 것을 다 잡아버리는 경우, 모든 예외를 던지고 코드가 깔끔해지는 것 같지만, 모든 예외를 다 던져서  
체크 예외가 무효화되고, 중요한 체크 예외도 놓칠 수 있게 된다. -> 컴파일 에러를 발생하지 않는다. -> 체크 예외를 쓰는 이유가 없어진다.  
꼭 필요한 경우가 아닌 이상 예외를 던지는 것은 좋지 않다. 따라서 언체크 예외를 잘 활용해야 한다.  

# 언체크 예외 활용
- 예외 공통 처리(ControllerAdvice) - RuntimeSQLException, RuntimeConnectException  
- Controller
  - Service
    - Repository - RuntimeSQLException
    - NetworkClient - RuntimeConnectException

런타임 예외의 경우 별도 선언없이 예외를 처리 로직을 두지 않아도 된다.  
언체크 예외에서는 예외를 던질 때 기존 예외도 같이 넣어서 던져야 한다. 그래야 스택트레이서에서 기존 예외를 확인 가능하다.  
자바 첫 설계 당시 체크 예외가 더 나은 선택이라고 생각해서, 자바 기본 제공 기능들에 체크 예외가 많다. 컴파일러로 다 잡을 수 있으니..  
라이브러리를 많이 사용하게 되면서, 여러 가지를 가져다 쓰는데, 처리 예외가 점점 늘어난다. 따라서 예외 처리 로직이 같이 늘어난다.  
어차피 예외를 처리하지 못하는데, 굳이 체크 예외를 통해 예외 처리를 전달할 필요는 없다.  
최근 라이브러리들은 대부분 런타임 예외(언체크 예외)를 기본으로 제공한다.  
런타임 예외를 할 때는, 문서화를 잘 해야한다. 어떤 예외가 발생할수 있는지!  

# 예외 포함과 스택 트레이스 (중요)
catch로 예외를 잡아서 로그를 찍지 않고, e.printStackTrace() 사용하면, System.out에 스택 트레이스를 출력한다. -> 실무에서 주의  
예외를 전환할 때 꼭 기존 예외를 포함해야 한다. 그렇지 않으면 스택 트레이스를 확인할 때 심각한 문제 발생!  
기존 예외들을 같이 스택트레이스에서 확인할 수 있다.  
기존 예외를 던질 때 같이 넣어주지 않으면, 기존 예외를 알 수 있는 방법이 없다.  
실제 기존 예외에 구체적인 예외 로그들을 확인 할 수 없게 된다.  
예외 전환시 꼭 기존 예외를 포함하자!!!!@@@  
RuntimeException(언체크 예외)를 만들 때 Throwable을 변수로 갖는 생성자를 꼭 만들어야 한다. super(cause)  









