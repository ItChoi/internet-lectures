# 트랜잭션 - 개념 이해 
단순히 회원가입시, 하나의 INSERT 쿼리를 날릴 때는 단순히 쿼리를 날리면 되지만, 계좌 이체를 예를 들었을 때, 계좌 이체라는 하나의 트랜잭션은 두 가지 작업이 있다. 

- 계좌이체
  1. A 통장 5000원 감소
  2. B 통장 5000원 증가
  - 두 작업이 모두 성공해야 하지만, 둘 중 하나만 증가가 됐을 때 심각한 문제를 초래한다. 

- DB 제공 트랜잭션을 활용해서 하나라도 실패할 때 계좌 이체 전의 상태로 돌아갈 수 있다.
  - 즉 모든 작업 성공 후 데이터베이스에 반영된 것을 commit, 이전 상태로 되돌리는 것을 rollback이라고 한다.

## 트랜잭션 ACID
1. 원자성
2. 일관성
3. 격리성
4. 지속성

격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준(Isolation level)을 선택 가능하다.
트랜잭션은 위에 네 가지 항목들을 보장해야 한다.
문제는 격리성이다. 격리성은 완전하게 보장하려면, 100개의 요청시, 병렬처리가 안 돼서 99개가 기다려야 한다.
따라서 동시 처리가 느려진다. 그래서 ANSI 표준으로 격리 수준을 네 단계로 나누어 정의했다.

- 트랜잭션 격리 수준
  1. READ UNCOMMITED: 커밋되지 않은 읽기
  2. READ COMMITED (커밋된 읽기)
  3. REPEATABLE READ (반복 가능한 읽기)
  4. SERIALIZABLE (직렬화 가능)

# 데이터베이스 연결 구조와 DB 세션
1. 이용자 -> 웹 서버 접근
2. 웹 서버는 데이터베이스에 커넥션을 맺는다
3. DB 내부에서 세션을 만든다.
4. 커넥션 맺은 모든 요청은 이 세션에서 실제 데이터베이스 동작(sql 시작, 트랜잭션 시작, 롤백, 등)을 한다.
5. 커넥션 종료를 하거나 데이터베이스 관리자가 강제로 종료할 시 세션은 종료된다.


# 트랜잭션 - DB 예제1 - 개념 이해
세션1이 신규 회원 추가하고 커밋되지 않은 상태에서는 데이터는 임시 상태로 되어 있고, 
임시 데이터는 해당 세션에서는 조회가 되지만, 다른 세션에서는 조회할 수 없다. 
왜냐하면 아직 커밋이 안 됐기 때문이다.  
커밋되지 않은 데이터를 다른 세션에서 보게되면, 데이터 정합성에 큰 문제가 생긴다. 세션에서 롤백해버리면,
커밋되지 않은 데이터를 읽은 세션에서 데이터가 계속적으로 쌓였을 때 문제가 될 수 있다.  
  
세션1이 데이터를 추가하고 커밋을 호출하면, 데이터 상태는 임시에서 완료 상태가 되고, 데이터베이스에 반영이 되고,  
다른 세션에서도 데이터를 조회할 수 있게 된다.  
커밋과 롤백은 트랜잭션 시작과 종료를 기준으로, 그 안에 삭제, 등록된 데이터도 트랜잭션 전으로 돌아간다.  


# 트랜잭션 - DB 예제2 - 자동 커밋, 수동 커밋
자동 커밋시 쿼리실행마다 커밋을 해버린다. insert 쿼리를 2번 쓴다 했을때 커밋을 두 번 한다.  
자동 커밋도 트랜잭션은 내부에서 일어나긴 하지만, 한 줄 단위로 짧은 트랜잭션이다.  
수동 커밋시에는 원하는 범위만큼 트랜잭션을 설정할 수 있다.  

# 트랜잭션 - DB 예제3 - 트랜잭션 실습

# 트랜잭션 - DB 예제4 - 계좌이체





