# 트랜잭션 - 개념 이해 
단순히 회원가입시, 하나의 INSERT 쿼리를 날릴 때는 단순히 쿼리를 날리면 되지만, 계좌 이체를 예를 들었을 때, 계좌 이체라는 하나의 트랜잭션은 두 가지 작업이 있다. 

- 계좌이체
  1. A 통장 5000원 감소
  2. B 통장 5000원 증가
  - 두 작업이 모두 성공해야 하지만, 둘 중 하나만 증가가 됐을 때 심각한 문제를 초래한다. 

- DB 제공 트랜잭션을 활용해서 하나라도 실패할 때 계좌 이체 전의 상태로 돌아갈 수 있다.
  - 즉 모든 작업 성공 후 데이터베이스에 반영된 것을 commit, 이전 상태로 되돌리는 것을 rollback이라고 한다.

## 트랜잭션 ACID
1. 원자성
2. 일관성
3. 격리성
4. 지속성

격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준(Isolation level)을 선택 가능하다.
트랜잭션은 위에 네 가지 항목들을 보장해야 한다.
문제는 격리성이다. 격리성은 완전하게 보장하려면, 100개의 요청시, 병렬처리가 안 돼서 99개가 기다려야 한다.
따라서 동시 처리가 느려진다. 그래서 ANSI 표준으로 격리 수준을 네 단계로 나누어 정의했다.

- 트랜잭션 격리 수준
  1. READ UNCOMMITED: 커밋되지 않은 읽기
  2. READ COMMITED (커밋된 읽기)
  3. REPEATABLE READ (반복 가능한 읽기)
  4. SERIALIZABLE (직렬화 가능)

# 데이터베이스 연결 구조와 DB 세션
1. 이용자 -> 웹 서버 접근
2. 웹 서버는 데이터베이스에 커넥션을 맺는다
3. DB 내부에서 세션을 만든다.
4. 커넥션 맺은 모든 요청은 이 세션에서 실제 데이터베이스 동작(sql 시작, 트랜잭션 시작, 롤백, 등)을 한다.
5. 커넥션 종료를 하거나 데이터베이스 관리자가 강제로 종료할 시 세션은 종료된다.


# 트랜잭션 - DB 예제1 - 개념 이해
세션1이 신규 회원 추가하고 커밋되지 않은 상태에서는 데이터는 임시 상태로 되어 있고, 
임시 데이터는 해당 세션에서는 조회가 되지만, 다른 세션에서는 조회할 수 없다. 
왜냐하면 아직 커밋이 안 됐기 때문이다.  
커밋되지 않은 데이터를 다른 세션에서 보게되면, 데이터 정합성에 큰 문제가 생긴다. 세션에서 롤백해버리면,
커밋되지 않은 데이터를 읽은 세션에서 데이터가 계속적으로 쌓였을 때 문제가 될 수 있다.  
  
세션1이 데이터를 추가하고 커밋을 호출하면, 데이터 상태는 임시에서 완료 상태가 되고, 데이터베이스에 반영이 되고,  
다른 세션에서도 데이터를 조회할 수 있게 된다.  
커밋과 롤백은 트랜잭션 시작과 종료를 기준으로, 그 안에 삭제, 등록된 데이터도 트랜잭션 전으로 돌아간다.  


# 트랜잭션 - DB 예제2 - 자동 커밋, 수동 커밋
자동 커밋시 쿼리실행마다 커밋을 해버린다. insert 쿼리를 2번 쓴다 했을때 커밋을 두 번 한다.  
자동 커밋도 트랜잭션은 내부에서 일어나긴 하지만, 한 줄 단위로 짧은 트랜잭션이다.  
수동 커밋시에는 원하는 범위만큼 트랜잭션을 설정할 수 있다.  

# 트랜잭션 - DB 예제3 - 트랜잭션 실습

# 트랜잭션 - DB 예제4 - 계좌이체

# DB 락 - 개념 이해
세션1이 데이터 변경 후 커밋을 하지 않은 상태에서 세션2가 동시에 같은 데이터 변경시 트랜잭션의 원자성이 꺠지게 된다.  
세션1, 세션2 어떤 상태에서 롤백을 해야 되는지 꼬이게 되는데,  
이런 문제를 방지하기 위해서는 세션1이 트랜잭션을 시작하고 데이터를 수정하고 커밋, 롤백하기 전까지 다른 세션에서 데이터를 수정할 수 없게 막아야 한다. 오직 읽기만  
세션1이 회원1의 이름을 아에이오우로 변경하려고 하고, 세션2가 호빵호빵으로 변경하려고 할 때, 먼저 접근한 세션이 우선권을 갖게 된다.  
따라서 세션1에 의해 변경될 때, 변경 전에 LOCK을 먼저 획득해야 한다. 획득 후 아에이오우로 변경되고 반영한다.  
세션1이 락을 획득 할 땐, 세션2는 락이 반환될 때 까지 기다린다. 그러나 무한정 기다리는 것은 아니다. 락 타임아웃 설정이 가능하다. 설저 안하면 기본 값이다.  
세션1이 커밋을 하면, 데이터베이스에 데이터가 반영이 되고, 락을 반환한다. 세션2는 락을 획득할 수 있다.  
즉 하나의 로우를 두 개의 세션이 접근해서 동시에 변경이 가해지지 않는다.

# DB 락 - 변경

# DB 락 - 조회
일반적인 조회는 락을 사용하지 않는다.  
즉 세션이 락을 획득하지 않고 조회를 할 수 있다. 다른 세션에서 변경이 가해져도 마찬가지다.  

그러나 데이터 조회시에도 락 획득이 필요할 때가 있다. 이런 경우 'select for update' 구문을 사용하면 된다.  
조회 시점에도 다른 세션에서 변경을 가할 수 없다.  

# 트랜잭션 - 적용1

# 트랜잭션 - 적용2
트랜잭션은 어디서 시작을 해야될까?  
바로 비즈니스 로직이 있는 서비스 계층에서 시작해야 한다. 그래야 문제시 모든 데이터 롤백이 가능하다.  
비즈니스 로직은 원자적으로 롤백이 되거나 커밋이 되어야 한다.  
트랜잭션은 커넥션이 필요하고, 트랜잭션을 사용하는 동안 같은 커넥션을 유지해야 같은 세션을 사용할 수 있다.  
같은 커넥션을 유지하려면 어떻게 해야 될 까?  
1. 단순한 방법은 커넥션을 파라미터로 전달한다.
   - 커넥션을 close하지말고 유지한채로 파라미터로 전달해서 사용해야 한다.
   - DataSource를 DI로 받아와서 커넥션 정보를 가져온다.
   - 가져온 커넥션 정보를 통해 setAutoCommit을 false로 해준다.
   - 비즈니스 로직 성공 / 실패 여부에 따라 커밋 및 롤백을 해주고 자동 커밋 모드를 true로 변경.
2. 스프링 활용














