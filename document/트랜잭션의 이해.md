# 트랜잭션 - 개념 이해 
단순히 회원가입시, 하나의 INSERT 쿼리를 날릴 때는 단순히 쿼리를 날리면 되지만, 계좌 이체를 예를 들었을 때, 계좌 이체라는 하나의 트랜잭션은 두 가지 작업이 있다. 

- 계좌이체
  1. A 통장 5000원 감소
  2. B 통장 5000원 증가
  - 두 작업이 모두 성공해야 하지만, 둘 중 하나만 증가가 됐을 때 심각한 문제를 초래한다. 

- DB 제공 트랜잭션을 활용해서 하나라도 실패할 때 계좌 이체 전의 상태로 돌아갈 수 있다.
  - 즉 모든 작업 성공 후 데이터베이스에 반영된 것을 commit, 이전 상태로 되돌리는 것을 rollback이라고 한다.

## 트랜잭션 ACID
1. 원자성
2. 일관성
3. 격리성
4. 지속성

격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준(Isolation level)을 선택 가능하다.
트랜잭션은 위에 네 가지 항목들을 보장해야 한다.
문제는 격리성이다. 격리성은 완전하게 보장하려면, 100개의 요청시, 병렬처리가 안 돼서 99개가 기다려야 한다.
따라서 동시 처리가 느려진다. 그래서 ANSI 표준으로 격리 수준을 네 단계로 나누어 정의했다.

- 트랜잭션 격리 수준
  1. READ UNCOMMITED: 커밋되지 않은 읽기
  2. READ COMMITED (커밋된 읽기)
  3. REPEATABLE READ (반복 가능한 읽기)
  4. SERIALIZABLE (직렬화 가능)

# 데이터베이스 연결 구조와 DB 세션
1. 이용자 -> 웹 서버 접근
2. 웹 서버는 데이터베이스에 커넥션을 맺는다
3. DB 내부에서 세션을 만든다.
4. 커넥션 맺은 모든 요청은 이 세션에서 실제 데이터베이스 동작(sql 시작, 트랜잭션 시작, 롤백, 등)을 한다.
5. 커넥션 종료를 하거나 데이터베이스 관리자가 강제로 종료할 시 세션은 종료된다.


# 트랜잭션 - DB 예제1 - 개념 이해
세션1이 신규 회원 추가하고 커밋되지 않은 상태에서는 데이터는 임시 상태로 되어 있고, 
임시 데이터는 해당 세션에서는 조회가 되지만, 다른 세션에서는 조회할 수 없다. 
왜냐하면 아직 커밋이 안 됐기 때문이다.  
커밋되지 않은 데이터를 다른 세션에서 보게되면, 데이터 정합성에 큰 문제가 생긴다. 세션에서 롤백해버리면,
커밋되지 않은 데이터를 읽은 세션에서 데이터가 계속적으로 쌓였을 때 문제가 될 수 있다.  
  
세션1이 데이터를 추가하고 커밋을 호출하면, 데이터 상태는 임시에서 완료 상태가 되고, 데이터베이스에 반영이 되고,  
다른 세션에서도 데이터를 조회할 수 있게 된다.  
커밋과 롤백은 트랜잭션 시작과 종료를 기준으로, 그 안에 삭제, 등록된 데이터도 트랜잭션 전으로 돌아간다.  


# 트랜잭션 - DB 예제2 - 자동 커밋, 수동 커밋
자동 커밋시 쿼리실행마다 커밋을 해버린다. insert 쿼리를 2번 쓴다 했을때 커밋을 두 번 한다.  
자동 커밋도 트랜잭션은 내부에서 일어나긴 하지만, 한 줄 단위로 짧은 트랜잭션이다.  
수동 커밋시에는 원하는 범위만큼 트랜잭션을 설정할 수 있다.  

# 트랜잭션 - DB 예제3 - 트랜잭션 실습

# 트랜잭션 - DB 예제4 - 계좌이체

# DB 락 - 개념 이해
세션1이 데이터 변경 후 커밋을 하지 않은 상태에서 세션2가 동시에 같은 데이터 변경시 트랜잭션의 원자성이 꺠지게 된다.  
세션1, 세션2 어떤 상태에서 롤백을 해야 되는지 꼬이게 되는데,  
이런 문제를 방지하기 위해서는 세션1이 트랜잭션을 시작하고 데이터를 수정하고 커밋, 롤백하기 전까지 다른 세션에서 데이터를 수정할 수 없게 막아야 한다. 오직 읽기만  
세션1이 회원1의 이름을 아에이오우로 변경하려고 하고, 세션2가 호빵호빵으로 변경하려고 할 때, 먼저 접근한 세션이 우선권을 갖게 된다.  
따라서 세션1에 의해 변경될 때, 변경 전에 LOCK을 먼저 획득해야 한다. 획득 후 아에이오우로 변경되고 반영한다.  
세션1이 락을 획득 할 땐, 세션2는 락이 반환될 때 까지 기다린다. 그러나 무한정 기다리는 것은 아니다. 락 타임아웃 설정이 가능하다. 설저 안하면 기본 값이다.  
세션1이 커밋을 하면, 데이터베이스에 데이터가 반영이 되고, 락을 반환한다. 세션2는 락을 획득할 수 있다.  
즉 하나의 로우를 두 개의 세션이 접근해서 동시에 변경이 가해지지 않는다.

# DB 락 - 변경

# DB 락 - 조회
일반적인 조회는 락을 사용하지 않는다.  
즉 세션이 락을 획득하지 않고 조회를 할 수 있다. 다른 세션에서 변경이 가해져도 마찬가지다.  

그러나 데이터 조회시에도 락 획득이 필요할 때가 있다. 이런 경우 'select for update' 구문을 사용하면 된다.  
조회 시점에도 다른 세션에서 변경을 가할 수 없다.  

# 트랜잭션 - 적용1

# 트랜잭션 - 적용2
트랜잭션은 어디서 시작을 해야될까?  
바로 비즈니스 로직이 있는 서비스 계층에서 시작해야 한다. 그래야 문제시 모든 데이터 롤백이 가능하다.  
비즈니스 로직은 원자적으로 롤백이 되거나 커밋이 되어야 한다.  
트랜잭션은 커넥션이 필요하고, 트랜잭션을 사용하는 동안 같은 커넥션을 유지해야 같은 세션을 사용할 수 있다.  
같은 커넥션을 유지하려면 어떻게 해야 될 까?  
1. 단순한 방법은 커넥션을 파라미터로 전달한다.
   - 커넥션을 close하지말고 유지한채로 파라미터로 전달해서 사용해야 한다.
   - DataSource를 DI로 받아와서 커넥션 정보를 가져온다.
   - 가져온 커넥션 정보를 통해 setAutoCommit을 false로 해준다.
   - 비즈니스 로직 성공 / 실패 여부에 따라 커밋 및 롤백을 해주고 자동 커밋 모드를 true로 변경.
2. 스프링 활용

# 트랜잭션 추상화
구현 기술마다 트랜잭션 사용 방법이 다르다.  
JDBC: connection.setAutoCommit, JPA: ...  
트랜잭션 구현 기술 변경시 로직 수정이 필요해진다.  
따라서 트랜잭션 기능을 추상화하면 된다.  
트랜잭션 인터페이스 -> 구현체: DI, 다형성으로 제어  
서비스 로직에서는 트랜잭션 인터페이스를 받아서 사용하면 된다.  
트랜잭션 인터페이스 뿐만 아니라, 스프링 프레임워크는 OCP, DI 등 OOP를 활용해 유연하게 대응 가능하도록 설계되어 있다.  

# 트랜잭션 동기화
스프링 제공 트랜잭션 매니저는 두 가지 역할을 한다.  
1. 트랜잭션 추상화
2. 리소스 동기화  
    - 같은 트랜잭션을 맞춰서 사용해야한다. 커네션을 파라미터로 전달하면서 사용하는 것이 아니다.
    - 스프링은 쓰레드 로컬을 사용해서 트랜잭션 동기화 매니저를 제공하면서 커넥션을 동기화해준다. -> 안전하게 멀티 쓰레드 환경에서도 커넥션을 잘 보관하고 유지해준다.  

# 트랜잭션 문제 해결 - 트랜잭션 매니저1
- 트랜잭션 동기화를 위해서는 DataSourceUtils.getConnection 사용해도 된다.

# 트랜잭션 문제 해결 - 트랜잭션 매니저2
- 트랜잭션 인터페이스
  - 인터페이스 내부에서 트랜잭션 매니저 이용
    - 커넥션 생성, 수동 커밋 모드 전환 후 해당 커넥션을 트랜잭션 동기화 매니저에 세팅
      - 트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션 보관하여 멀티 쓰레드 환경에서도 안전하게 커넥션을 이용 가능하다.
        - 트랜잭션이 필요한 곳에서 DataSourceUtils.getConnection() 사용해서 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내 사용한다.
          - 획득한 커넥션으로 SQL 전달 후 실행
            - 로직 실행 후 트랜잭션 종료 -> 커밋 or 롤백
              - 데이터베이스 트랜잭션 커밋 or 롤백 후 전체 리소스 정리

# 트랜잭션 문제 해결 - 트랜잭션 템플릿
- 트랜잭션의 패턴 반복
  - 트랜잭션 시작, 로직 수행, 커밋 or 롤백
    - 각 서비스가 다를 때 마다 try catch finally도 반복된다.
      - 반복되는 형태에 다른 점은 비즈니스 로직뿐이다.

이러한 패턴의 반복 문제는 템플릿 콜백 패턴을 활용시 해결 가능하다.  
다행히도 스프링은 트랜잭션 템플릿 클래스(TransactionTemplate)를 제공한다.  
트랜잭션 시작, 커밋 롤백 코드가 모두 제거된다.
그러나 서비스 로직에 비즈니스로직 뿐만 아니라, 트랜잭션 처리 기술 로직이 함께 포함되어 있다.  
즉, 핵심 기능(비즈니스 로직)과 부가 기능(트랜잭션) 한 곳에 있으면 두 가지 관심사가 하나의 클래스에 정의되고 처리된다.  
이 말은, 코드를 유지보수하기 어려워질수도 있다. 따라서 비즈니스 로직에는 핵심 로직만 존재하게 하는 것이 중요하다. -> 트랜잭션 AOP

# 트랜잭션 문제 해결 - 트랜잭션 AOP 이해
트랜잭션 템플릿 코드와 스프링 AOP를 통해 반복되는 코드를 제거하고, 비즈니스 로직에 핵심 기능만 남겨둘 수 있게 해준다.  
- 프록시를 도입한다.
  - 클라이언트는 서비스 로직이 아니라, 프록시를 호출한다. 
    - 먼저 프록시를 호출해서 트랜잭션 시작과 종료와 비즈니스 로직 정보를 담고, 비즈니스 로직 정보를 처리할 시점에 비즈니스 로직을 호출한다.
      - AOP를 이용해 트랜잭션 로직을 이 곳에 담으면, 핵심 서비스에는 비즈니스 로직만을 담을 수 있다. 












